<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <link rel="shortcut icon" href="../../img/favicon.ico" />
    <title>Effective Software Testing - phautelman</title>
    <link rel="stylesheet" href="../../css/theme.css" />
    <link rel="stylesheet" href="../../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "Effective Software Testing";
        var mkdocs_page_input_path = "tutorials/effective-software-testing.md";
        var mkdocs_page_url = null;
      </script>
    
    <!--[if lt IE 9]>
      <script src="../../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
      <script>hljs.highlightAll();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href="../.." class="icon icon-home"> phautelman
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../..">Home</a>
                </li>
              </ul>
              <p class="caption"><span class="caption-text">Tutorials</span></p>
              <ul class="current">
                  <li class="toctree-l1"><a class="reference internal" >Open WebUI</a>
    <ul>
                <li class="toctree-l2"><a class="reference internal" href="../build-your-local-ai/">Build Your Local AI. From Zero to a Custom ChatGPT Interface with Ollama & Open WebUI</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../open-webui-rag/">Supercharge Your Local AI with RAG and Custom Knowledge Bases</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../open-webui-action-tools/">Beyond Text. Equipping Your Open WebUI AI with Action Tools</a>
                </li>
    </ul>
                  </li>
                  <li class="toctree-l1 current"><a class="reference internal current" >Software</a>
    <ul class="current">
                <li class="toctree-l2 current"><a class="reference internal current" href="#">Effective Software Testing</a>
    <ul class="current">
    <li class="toctree-l3"><a class="reference internal" href="#why-testing-is-important">Why Testing is Important</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#the-testing-pyramid">The Testing Pyramid</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#unit-testing">Unit Testing</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#integration-testing">Integration Testing</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#system-testing">System Testing</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#when-to-use-each">When to Use Each</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#specification-based-testing">Specification-Based Testing</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#steps-for-specification-based-testing">Steps for Specification-Based Testing</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#example-walkthrough-user-registration-function">Example Walkthrough: User Registration Function</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#structural-testing-and-code-coverage">Structural Testing and Code Coverage</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#steps-for-structural-testing">Steps for Structural Testing</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#code-coverage-criteria">Code Coverage Criteria</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#how-to-apply-mcdc-modified-conditiondecision-coverage">How to Apply MC/DC (Modified Condition/Decision Coverage)</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#example-walkthrough-of-mcdc-coverage">Example Walkthrough of MC/DC Coverage</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#additional-notes">Additional Notes</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#designing-contracts">Designing Contracts</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#understanding-contracts">Understanding Contracts</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#contracts-vs-validation">Contracts vs. Validation</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#implementing-contracts">Implementing Contracts</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#strong-vs-weak-conditions">Strong vs. Weak Conditions</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#example-complex-financial-system">Example: Complex Financial System</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#property-based-testing">Property-Based Testing</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#test-doubles-and-mocks">Test Doubles and Mocks</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#types-of-test-doubles">Types of Test Doubles</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#advantages-of-using-test-doubles">Advantages of Using Test Doubles</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#introduction-to-mockito">Introduction to Mockito</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#designing-for-testability">Designing for Testability</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#advanced-mocking-techniques">Advanced Mocking Techniques</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#best-practices-and-common-pitfalls">Best Practices and Common Pitfalls</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#handling-unmockable-components">Handling Unmockable Components</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#conclusion">Conclusion</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#test-driven-development">Test-Driven Development</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#tdd-process">TDD Process</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#advantages-of-tdd">Advantages of TDD</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#what-does-research-say-about-tdd">What Does Research Say About TDD?</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#when-not-to-use-tdd">When Not to Use TDD</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#integrating-tdd-and-proper-testing">Integrating TDD and Proper Testing</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#example-walkthrough">Example Walkthrough</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#writing-larger-tests">Writing Larger Tests</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#test-code-quality">Test Code Quality</a>
    </li>
    </ul>
                </li>
    </ul>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">Software Tools</span></p>
              <ul>
                  <li class="toctree-l1"><a class="" href="https://pahautelman.github.io/mcdc-calculator/">MC/DC Calculator</a>
                  </li>
                  <li class="toctree-l1"><a class="" href="https://pahautelman.github.io/interactive-fish-cluser/">Interactive Fish Cluster</a>
                  </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../..">phautelman</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../.." class="icon icon-home" aria-label="Docs"></a></li>
          <li class="breadcrumb-item">Tutorials</li>
          <li class="breadcrumb-item">Software</li>
      <li class="breadcrumb-item active">Effective Software Testing</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="effective-software-testing-a-developers-guide">Effective Software Testing: A Developer's Guide</h1>
<p>Effective and systematic software testing is critical for ensuring the reliability and quality of software systems. This guide provides a comprehensive overview of best code testing practices, inspired by the book 'Effective Software Testing: A Developer's Guide' by the software quality and testing expert Maurício Aniche 🐐.</p>
<p>The goal is to help developers understand the importance of proper testing, how to approach it systematically, and how to implement it effectively in their projects.</p>
<p><br/></p>
<h2 id="why-testing-is-important">Why Testing is Important</h2>
<p><strong>Quality Assurance</strong>: Testing is essential because software failures can have severe consequences for businesses and end-users. Developers bear responsibility for the quality of the software they produce.</p>
<p><strong>Bug Prevention</strong>: While simplicity in code design can reduce bugs, it cannot eliminate them. Testing is necessary to catch errors that arise from complex interactions within the software.</p>
<p><strong>Cost-Efficiency</strong>: The cost of fixing bugs in production is often higher than the cost of thorough testing during development. Systematic testing reduces the risk of releasing buggy software, saving time and resources in the long run.</p>
<p><strong>Code Improvement</strong>: Testing often leads to improvements in code quality. As developers write tests, they frequently identify areas where the code can be refactored for better clarity, efficiency, or maintainability. This process of writing tests and refactoring code results in more readable, maintainable, and robust software.</p>
<p><strong>Confidence in Changes</strong>: A comprehensive test suite gives developers confidence to make changes or add new features, knowing that existing functionality can be quickly verified.</p>
<p><br/></p>
<h2 id="the-testing-pyramid">The Testing Pyramid</h2>
<h3 id="unit-testing">Unit Testing</h3>
<ul>
<li><strong>Focus</strong>: Tests individual units (e.g., methods or functions) in isolation</li>
<li><strong>Benefits</strong>: Fast, easy to write, and control</li>
<li><strong>Limitations</strong>: May not catch bugs that arise from interactions between units</li>
</ul>
<h3 id="integration-testing">Integration Testing</h3>
<ul>
<li><strong>Focus</strong>: Tests interactions between different units or with external systems</li>
<li><strong>Benefits</strong>: Identifies issues in the integration layer</li>
<li><strong>Limitations</strong>: More complex and time-consuming to write</li>
</ul>
<h3 id="system-testing">System Testing</h3>
<ul>
<li><strong>Focus</strong>: Tests the entire system as a whole, including all components and their interactions</li>
<li><strong>Benefits</strong>: Provides a realistic view of how the system behaves in production</li>
<li><strong>Limitations</strong>: Slower to execute, more prone to flaky results, and harder to write</li>
</ul>
<h3 id="when-to-use-each">When to Use Each</h3>
<ul>
<li><strong>Unit Tests</strong>: For all business rules and logic</li>
<li><strong>Integration Tests</strong>: For complex integrations with external services</li>
<li><strong>System Tests</strong>: For critical workflows and high-risk areas of the application</li>
</ul>
<p><br/></p>
<h2 id="specification-based-testing">Specification-Based Testing</h2>
<p>Specification-based testing derives test cases from the software's requirements, ensuring the code meets its intended functionality.</p>
<h3 id="steps-for-specification-based-testing">Steps for Specification-Based Testing</h3>
<ol>
<li><strong>Understand the Requirements</strong>: Identify what the software should and should not do based on requirements or user stories</li>
<li><strong>Explore the Program</strong>: Investigate how the software handles various inputs and outputs</li>
<li><strong>Identify Partitions</strong>: Group inputs into partitions where the software is expected to behave similarly</li>
<li><strong>Identify Boundaries</strong>: Focus on edge cases, such as values around decision points (e.g., &gt;, &lt;, == operators)</li>
<li><strong>Devise Test Cases</strong>: Create tests based on identified partitions and boundaries, prioritizing edge cases and unique combinations</li>
<li><strong>Automate Test Cases</strong>: Implement tests using tools like JUnit, ensuring tests are easy to read and maintain</li>
<li><strong>Augment with Creativity</strong>: Use experience and intuition to identify additional test cases that may not be directly derived from the specifications</li>
</ol>
<h3 id="example-walkthrough-user-registration-function">Example Walkthrough: User Registration Function</h3>
<p>Consider a user registration function with a username and password:</p>
<p><strong>Requirements</strong>: The username must be 3-20 characters long and contain only alphanumeric characters. The password must be at least 8 characters long and contain at least one number, one capital letter, and one symbol.</p>
<p><strong>Partitions</strong>:</p>
<ul>
<li>Username: null, too short, too long, invalid, valid</li>
<li>Password: null, too short, invalid, valid</li>
</ul>
<p><strong>Boundaries</strong>: The test cases will include usernames of different lengths, from the shortest (2 characters—invalid, 3 characters—valid) to the longest (20 characters—valid, 21 characters—invalid). The same applies to password length: 7 characters—invalid, 8 characters—valid.</p>
<p><strong>Test Cases</strong>:</p>
<ul>
<li>Test an empty username</li>
<li>Test an empty password</li>
<li>Test a valid username that is too short</li>
<li>Test an invalid username of 3 and 20 characters</li>
<li>Test a valid username</li>
<li>Test a valid username that is too short</li>
<li>Test a valid password that is too short</li>
<li>Test an invalid password of 8 characters</li>
<li>Test a valid password</li>
</ul>
<p><strong>Augment with Experience</strong>: We might know from experience that users may attempt to use symbols in their passwords that could pose security risks (e.g., backticks (`), pipe (|), angle brackets (&lt;, &gt;), etc.). Test cases should be added to ensure that passwords containing such characters are deemed invalid.</p>
<p><br/></p>
<h2 id="structural-testing-and-code-coverage">Structural Testing and Code Coverage</h2>
<p>Structural testing, also known as white-box testing, involves testing the internal structure of the code to ensure thorough coverage of all its components. Unlike specification-based (black-box) testing, which focuses on functional requirements, structural testing delves into the code to ensure that all paths, branches, and conditions are adequately tested.</p>
<h3 id="steps-for-structural-testing">Steps for Structural Testing</h3>
<ol>
<li><strong>Perform Specification-Based Testing</strong>: Begin with tests derived from functional requirements to validate expected behaviour</li>
<li><strong>Review Code</strong>: Carefully read the unit implementation to understand the developer's key coding decisions</li>
<li><strong>Run Tests with Coverage Tools</strong>: Execute the devised test suite using code coverage tools</li>
<li><strong>Analyze Coverage Gaps</strong>: Identify any untested code segments revealed by the coverage analysis</li>
<li><strong>Decide on Testing Missed Code</strong>: Evaluate whether the untested code is significant enough to warrant additional testing</li>
<li><strong>Iterate and Refine</strong>: Revisit the source code to identify other test cases that could be derived from the code structure</li>
</ol>
<h3 id="code-coverage-criteria">Code Coverage Criteria</h3>
<p><strong>Line Coverage</strong>: Ensures that every line of code is executed at least once during testing. It is the most basic level of coverage.</p>
<p><strong>Branch Coverage</strong>: Tests each branch of decision points (e.g., every true/false path of an if statement). This ensures that all possible outcomes of conditional statements are exercised.</p>
<p><strong>Condition Coverage</strong>: It focuses on testing each individual condition within a decision point, ensuring that each condition has been evaluated as true or false.</p>
<p><strong>Modified Condition/Decision Coverage (MC/DC)</strong>: MC/DC ensures that each condition within a decision affects the outcome of that decision independently of other conditions. This reduces the number of test cases while still providing rigorous testing of complex conditional logic.</p>
<p><strong>Path Coverage</strong>: Ensures that all possible execution paths through the code are tested. This is more comprehensive than branch coverage as it accounts for all the possible execution sequences.</p>
<blockquote>
<p><em><strong>Fun fact:</strong> MC/DC is frequently required by industry standards for safety-critical systems, such as aviation, medicine, and infrastructure.</em></p>
</blockquote>
<h3 id="how-to-apply-mcdc-modified-conditiondecision-coverage">How to Apply MC/DC (Modified Condition/Decision Coverage)</h3>
<ol>
<li><strong>Identify the conditions and decision</strong>: List all individual conditions in the decision and identify the overall decision being evaluated</li>
<li><strong>Create a truth table</strong>: List all possible combinations of the conditions and calculate the decision outcome for each combination</li>
<li><strong>Determine independence pairs for each condition</strong>: Find pairs of test cases for each condition where only that condition changes value and the change causes the decision outcome to change</li>
<li><strong>Select the minimum set of test cases</strong>: Choose test cases that demonstrate the independent effect of each condition</li>
<li><strong>Verify coverage</strong>: Confirm each condition independently affects the decision</li>
</ol>
<h3 id="example-walkthrough-of-mcdc-coverage">Example Walkthrough of MC/DC Coverage</h3>
<p>For the decision <code>if (A &amp;&amp; (B || C))</code>:</p>
<table>
<thead>
<tr>
<th>Test</th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>T</td>
<td>T</td>
<td>T</td>
<td>T</td>
</tr>
<tr>
<td>2</td>
<td>T</td>
<td>T</td>
<td>F</td>
<td>T</td>
</tr>
<tr>
<td>3</td>
<td>T</td>
<td>F</td>
<td>T</td>
<td>T</td>
</tr>
<tr>
<td>4</td>
<td>T</td>
<td>F</td>
<td>F</td>
<td>F</td>
</tr>
<tr>
<td>5</td>
<td>F</td>
<td>T</td>
<td>T</td>
<td>F</td>
</tr>
<tr>
<td>6</td>
<td>F</td>
<td>T</td>
<td>F</td>
<td>F</td>
</tr>
<tr>
<td>7</td>
<td>F</td>
<td>F</td>
<td>T</td>
<td>F</td>
</tr>
<tr>
<td>8</td>
<td>F</td>
<td>F</td>
<td>F</td>
<td>F</td>
</tr>
</tbody>
</table>
<p><strong>Condition A</strong>: </p>
<ul>
<li>Test with <code>A = true</code> and <code>A = false</code> ensuring different outcomes, with B or C kept constant.</li>
<li>Test case 1: <code>A = true, B = true, C = true</code> (Result: <code>true</code>)</li>
<li>Test case 5: <code>A = false, B = true, C = true</code> (Result: <code>false</code>)</li>
<li>Explanation: These test cases show A independently affecting the outcome when B and C are true. When A changes from <code>true</code> to <code>false</code>, the overall result is <code>false</code>, and it demonstrates A's independent effect.</li>
<li>Other pairs of test cases: {2, 6}, {3, 7}</li>
</ul>
<p><strong>Condition B</strong>: </p>
<ul>
<li>Test with <code>B = true</code> and <code>B = false</code>, ensuring different outcomes, with A or C constant.</li>
<li>Test case 2: <code>A = true, B = true, C = false</code> (Result: <code>true</code>)</li>
<li>Test case 4: <code>A = true, B = false, C = false</code> (Result: <code>false</code>)</li>
<li>Explanation: These test cases demonstrate B's independent effect. When B changes from <code>true</code> to <code>false</code>, the overall result changes from <code>true</code> to <code>false</code>.</li>
<li>No other pairs of tests.</li>
</ul>
<p><strong>Condition C</strong>:</p>
<ul>
<li>Test with <code>C = true</code> and <code>C = false</code>, ensuring different outcomes, with A or B constant.</li>
<li>Test case 3: <code>A = true, B = false, C = true</code> (Result: <code>true</code>)</li>
<li>Test case 4: <code>A = true, B = false, C = false</code> (Result: <code>false</code>)</li>
<li>Explanation: These test cases show C's independent effect. When C changes from <code>true</code> to <code>false</code>, the overall result changes from <code>true</code> to <code>false</code>.</li>
<li>No other pairs of tests.</li>
</ul>
<p><strong>Select Minimum Sets of Test Cases</strong>:</p>
<ul>
<li>The test cases {2, 3, 4, 6} exercise the independent effect of all conditions.</li>
<li>{2, 6} exercise A</li>
<li>{2, 4} exercise B</li>
<li>{3, 4} exercise C</li>
<li>So we only need to write four tests to ensure thorough coverage of this decision.</li>
</ul>
<p>Use this calculator to find minimal test cases needed to achieve MC/DC coverage: <a href="https://pahautelman.github.io/mcdc-calculator/">MC/DC Calculator</a></p>
<h3 id="additional-notes">Additional Notes</h3>
<p><strong>Augmenting Specification-Based Testing</strong>: Structural testing should augment specification-based testing. This ensures that functional requirements are met and that the code behaves as expected in all scenarios.</p>
<p><strong>Using Source Code for Structural Testing</strong>: The source code is valuable for identifying test cases that may not be evident from the requirements alone. Structural testing leverages the code to uncover potential issues that specification-based testing might miss.</p>
<p><br/></p>
<h2 id="designing-contracts">Designing Contracts</h2>
<p>Designing contracts is a crucial aspect of software development that helps ensure the reliability and correctness of complex systems. This section will explore the concept of contracts, including pre-conditions, post-conditions, and invariants, and how they differ from validation.</p>
<h3 id="understanding-contracts">Understanding Contracts</h3>
<p>Contracts in software development are formal agreements between different parts of a program about their behaviour. They specify what conditions must be met before a method is called (pre-conditions), what conditions will be true after the method executes (post-conditions), and what conditions remain constant throughout the execution of a method or the lifetime of an object (invariants).</p>
<h4 id="pre-conditions-post-conditions-and-invariants">Pre-conditions, Post-conditions, and Invariants</h4>
<p><strong>Pre-conditions</strong>:</p>
<ul>
<li>Define what the method needs to function properly</li>
<li>Ensure that input values received by the method adhere to what is required</li>
<li>Example: A method that calculates square root might have a pre-condition that the input must be non-negative</li>
</ul>
<p><strong>Post-conditions</strong>:</p>
<ul>
<li>Specify what the method guarantees as an outcome</li>
<li>Ensure that the method returns what it promises to other methods</li>
<li>Help detect bugs by throwing exceptions instead of returning invalid values</li>
<li>Example: A method that sorts an array might have a post-condition that the returned array is in ascending order</li>
</ul>
<p><strong>Invariants</strong>:</p>
<ul>
<li>Conditions that always hold true for a class or object</li>
<li>Maintained throughout the execution of methods</li>
<li>Example: A binary search tree class might have an invariant that the left child is always smaller than the parent node</li>
</ul>
<h3 id="contracts-vs-validation">Contracts vs. Validation</h3>
<p>While both contracts and validation aim to ensure correct program behaviour, they serve different purposes:</p>
<p><strong>Contracts</strong> define the expected behaviour and interactions between different parts of a program. They are typically checked during development and may be disabled in production for performance reasons.</p>
<p><strong>Validation</strong> is about checking the correctness of data, usually at runtime, and is typically always active, even in production environments.</p>
<h3 id="implementing-contracts">Implementing Contracts</h3>
<p>There are several ways to implement contracts in code:</p>
<p><strong>Using assert keyword (in Java)</strong>:</p>
<pre><code class="language-java">assert taxValue &gt;= 0 : &quot;Calculated tax value cannot be negative!&quot;;
</code></pre>
<ul>
<li>Can be disabled via JVM parameter in production</li>
<li>Use with caution if you don't have full control of your production environment</li>
</ul>
<p><strong>Using conditional statements</strong>:</p>
<pre><code class="language-java">if (taxValue &lt; 0) {
    throw new IllegalStateException(&quot;Calculated tax value cannot be negative!&quot;);
}
</code></pre>
<ul>
<li>More suitable when you need the checks to always be active</li>
</ul>
<p><strong>Documentation</strong>: Clearly stating pre-conditions and post-conditions in method documentation is crucial and helps other developers understand how to use the method correctly.</p>
<h3 id="strong-vs-weak-conditions">Strong vs. Weak Conditions</h3>
<ul>
<li><strong>Strong conditions</strong> halt execution when violated</li>
<li><strong>Weak conditions</strong> log errors but allow execution to continue</li>
<li>Strong conditions are generally preferred as they reduce the range of potential errors in the code</li>
</ul>
<h3 id="example-complex-financial-system">Example: Complex Financial System</h3>
<p>Consider a large software system handling complex financial processes:</p>
<ul>
<li>The system chains calls to several subroutines in a complex flow</li>
<li>Results from one class are passed to the next class, and so on</li>
<li>At some point, a TaxCalculator class is called</li>
<li>Based on the requirements, calculations in TaxCalculator only make sense for positive numbers</li>
</ul>
<p>To handle this restriction:</p>
<ol>
<li>Define clear contracts for each class, including TaxCalculator</li>
<li>Establish pre-conditions (e.g., input must be positive), post-conditions (e.g., calculated tax is non-negative), and invariants for the class</li>
<li>Implement these contracts in the code using assertions or conditional checks</li>
<li>Document the contracts clearly in the class and method documentation</li>
</ol>
<p>By implementing contracts, we can catch errors early, improve code reliability, and make the system's behaviour more predictable and maintainable.</p>
<p><br/></p>
<h2 id="property-based-testing">Property-Based Testing</h2>
<p><em>[TODO]</em></p>
<p><br/></p>
<h2 id="test-doubles-and-mocks">Test Doubles and Mocks</h2>
<p>In software development, classes often depend on other classes to perform their functions. While testing multiple classes together can be desirable, testing a unit in isolation is frequently necessary without relying on its dependencies. This is where test doubles come into play.</p>
<p>Consider a scenario where class A depends on classes B and C, which in turn have their own dependencies:</p>
<pre><code>A -&gt; B -&gt; Database
  -&gt; C -&gt; External service
</code></pre>
<p>Testing A and its concrete dependencies might be too slow, too complex, or require too much setup. Test doubles allow us to isolate A and test it effectively.</p>
<h3 id="types-of-test-doubles">Types of Test Doubles</h3>
<p><strong>Dummies</strong>:</p>
<ul>
<li>Simple objects passed to the class under test but never actually used</li>
<li>They fulfil parameter requirements without impacting the test</li>
</ul>
<p><strong>Fake Objects</strong>:</p>
<ul>
<li>Have working implementations of the simulated class, but in a simpler way</li>
<li>Example: A fake database class using an ArrayList instead of a real database</li>
</ul>
<p><strong>Stubs</strong>:</p>
<ul>
<li>Provide hard-coded answers to calls made during the test</li>
<li>Don't have fully working implementations</li>
<li>Most popular type of simulation</li>
<li>Used when you need a dependency to return a specific value for the method under test to continue execution</li>
</ul>
<p><strong>Mocks</strong>:</p>
<ul>
<li>Similar to stubs, but with additional capabilities</li>
<li>Allow configuration of how they respond to method calls</li>
<li>Record all interactions, enabling assertions on these interactions</li>
</ul>
<p><strong>Spies</strong>:</p>
<ul>
<li>Wrap around real objects and observe their behaviour</li>
<li>Used when the actual implementation is easier to use, but you still want to assert how the method under test interacts with the dependency</li>
<li>Less common than other test doubles</li>
</ul>
<h3 id="advantages-of-using-test-doubles">Advantages of Using Test Doubles</h3>
<ul>
<li><strong>Control</strong>: Test doubles provide complete control over the dependency's behaviour, allowing simulation of various scenarios</li>
<li><strong>Speed</strong>: Tests with doubles run faster as they bypass the overhead of real implementations</li>
<li><strong>Design Reflection</strong>: Using test doubles encourages developers to think critically about class interactions, leading to better-designed interfaces and contracts</li>
</ul>
<h3 id="introduction-to-mockito">Introduction to Mockito</h3>
<p>Mocking frameworks like Mockito offer a simple API for setting up stubs and defining expectations on mock objects. Here are some crucial methods in Mockito:</p>
<p><strong>Creating a mock</strong>:</p>
<pre><code class="language-java">MockObject mock = mock(ClassToMock.class);
</code></pre>
<p><strong>Defining stub behaviour</strong>:</p>
<pre><code class="language-java">when(mock.someMethod()).thenReturn(someValue);
</code></pre>
<p><strong>Verifying interactions</strong>:</p>
<pre><code class="language-java">verify(mock).someMethod();
</code></pre>
<p><strong>Example using Mockito</strong>:</p>
<pre><code class="language-java">// Create a mock
List&lt;String&gt; mockedList = mock(List.class);

// Define behavior
when(mockedList.get(0)).thenReturn(&quot;first&quot;);

// Use the mock
System.out.println(mockedList.get(0)); // Outputs &quot;first&quot;

// Verify interaction
verify(mockedList, times(1)).get(0);
</code></pre>
<h3 id="designing-for-testability">Designing for Testability</h3>
<p>It's important to note that changing product code to make testing easier is acceptable and often encouraged. This practice can lead to improvements in the overall code quality and design. When you find your code difficult to test, it's usually a sign that the code could benefit from refactoring. Common changes include:</p>
<ul>
<li>Introducing interfaces for better abstraction</li>
<li>Breaking down oversized methods into smaller, more focused ones</li>
<li>Using dependency injection to make dependencies more flexible and more accessible to mock</li>
</ul>
<p>Remember, code that is easy to test is often more modular, has clearer responsibilities, and is generally of higher quality.</p>
<h3 id="advanced-mocking-techniques">Advanced Mocking Techniques</h3>
<h4 id="argument-capturing">Argument Capturing</h4>
<p>Argument capturing allows us to inspect arguments passed to mock methods. This is particularly useful when verifying complex objects passed to a method or when the method doesn't return a value.</p>
<h4 id="simulating-exceptions">Simulating Exceptions</h4>
<p>Simulating exceptions with mocks helps us test how the system would behave in unexpected scenarios. This is particularly valuable when your application interacts with external systems that may not always behave as expected.</p>
<pre><code class="language-java">@Test
void handleDatabaseConnectionFailure() {
    // Arrange
    DatabaseService mockDb = mock(DatabaseService.class);
    when(mockDb.connect()).thenThrow(new ConnectionException(&quot;Database unavailable&quot;));

    MyService service = new MyService(mockDb);

    // Act &amp; Assert that our service handles a database connection failure
    // correctly translate failure into ServiceUnavailableException
    assertThrows(ServiceUnavailableException.class, () -&gt; {
        service.performCriticalOperation();
    });
}
</code></pre>
<h3 id="best-practices-and-common-pitfalls">Best Practices and Common Pitfalls</h3>
<ul>
<li><strong>Limit Mocking</strong>: Don't overuse mocks. Tests with real dependencies are often more effective at finding real bugs</li>
<li><strong>Mock Wisely</strong>: Good candidates for mocking include slow dependencies, external infrastructure, and cases that are hard to simulate (e.g., exceptions)</li>
<li><strong>Avoid Mocking</strong>: Entities, value objects, or classes that represent business concepts; native Java libraries and utility methods; simple objects that are easy to instantiate</li>
<li><strong>Keep Tests Clean</strong>: Use helper methods or classes to encapsulate common setup logic</li>
<li><strong>Design Stable Contracts</strong>: For mocks to work effectively in large codebases, design careful and stable contracts between classes</li>
<li><strong>Be Aware of Coupling</strong>: Mocks can increase coupling between test and production code. Be mindful of this when designing your tests</li>
</ul>
<h3 id="handling-unmockable-components">Handling Unmockable Components</h3>
<p>Some components, like static methods or date/time operations, can be challenging to mock. Strategies for dealing with these include:</p>
<h4 id="wrapper-classes">Wrapper Classes</h4>
<p>Encapsulate unmockable components in wrapper classes that can be easily mocked.</p>
<p>Example for date and time operations:</p>
<pre><code class="language-java">public class Clock {
  public LocalDateTime now() {
    return LocalDateTime.now();
  }
}
</code></pre>
<h4 id="dependency-injection">Dependency Injection</h4>
<p>Dependency Injection (DI) is a design pattern that makes it easier to test classes by allowing dependencies to be easily swapped out:</p>
<pre><code class="language-java">// Without Dependency Injection
public class UserService {
    private DatabaseConnection db = new DatabaseConnection();

    public User getUser(int id) {
        return db.fetchUser(id);
    }
}

// With Dependency Injection
public class UserService {
    private DatabaseConnection db;

    // Constructor Injection
    public UserService(DatabaseConnection db) {
        this.db = db;
    }

    public User getUser(int id) {
        return db.fetchUser(id);
    }
}

// In your test
@Test
void testGetUser() {
    // Arrange
    DatabaseConnection mockDb = mock(DatabaseConnection.class);
    when(mockDb.fetchUser(1)).thenReturn(new User(1, &quot;John Doe&quot;));

    UserService userService = new UserService(mockDb);

    // Act
    User user = userService.getUser(1);

    // Assert
    assertEquals(&quot;John Doe&quot;, user.getName());
    verify(mockDb).fetchUser(1);
}
</code></pre>
<h4 id="mocking-static-methods">Mocking Static Methods</h4>
<p>Mockito 3.4.0 and later versions provide support for mocking static methods:</p>
<pre><code class="language-java">import static org.mockito.Mockito.*;
import static org.mockito.ArgumentMatchers.*;

class MyServiceTest {

    @Test
    void testStaticMethodMocking() {
        try (MockedStatic&lt;UtilityClass&gt; mockedStatic = mockStatic(UtilityClass.class)) {
            // Arrange
            mockedStatic.when(() -&gt; UtilityClass.staticMethod(anyString()))
                        .thenReturn(&quot;mocked result&quot;);

            // Act
            String result = MyService.methodUsingStaticUtility(&quot;input&quot;);

            // Assert
            assertEquals(&quot;expected result&quot;, result);
            mockedStatic.verify(() -&gt; UtilityClass.staticMethod(&quot;input&quot;));
        }
    }
}
</code></pre>
<h3 id="conclusion">Conclusion</h3>
<p>Test doubles and mocks are powerful tools for creating effective unit tests. By understanding when and how to use them, developers can create robust test suites that verify code correctness and contribute to better software design. Remember to balance the use of test doubles with tests that use real dependencies to ensure comprehensive coverage and realistic testing scenarios.</p>
<p>By incorporating these advanced techniques and design principles, you can create more robust and flexible tests. <em>Remember that the goal is not just to increase test coverage but to improve the overall design and reliability of our software.</em></p>
<p><br/></p>
<h2 id="test-driven-development">Test-Driven Development</h2>
<p>Test-driven development (TDD) is a software development methodology in which tests are written before the actual code implementation. This approach inverts the traditional development process, where code is typically implemented first and tested later. TDD emphasizes writing automated test cases for each piece of functionality before writing the code to implement that functionality.</p>
<h3 id="tdd-process">TDD Process</h3>
<p>The TDD process consists of three primary steps, often referred to as the Red-Green-Refactor cycle:</p>
<ol>
<li><strong>Write a Test (Red)</strong>: Begin by writing an automated test for the next piece of functionality. Initially, this test will fail because the required implementation does not yet exist</li>
<li><strong>Implement the Functionality (Green)</strong>: Write the minimum code necessary to pass the test. The focus is on implementing just enough to meet the test's expectations</li>
<li><strong>Refactor</strong>: Clean up and improve the production and test code while ensuring all tests continue to pass. Refactoring should reduce the amount of code needed to satisfy the tests and improve the production code's readability, maintainability, and design</li>
</ol>
<p>These steps are repeated iteratively until the full functionality is implemented and all tests pass.</p>
<h3 id="advantages-of-tdd">Advantages of TDD</h3>
<p>Adopting a test-driven development approach can provide several benefits:</p>
<ul>
<li><strong>Improved Code Quality</strong>: By writing tests first, TDD encourages better design decisions and helps catch defects early in the development process, leading to higher-quality code</li>
<li><strong>Rapid Feedback</strong>: The tight feedback loop provided by TDD allows developers to quickly identify and address issues, preventing them from compounding over time</li>
<li><strong>Enhanced Collaboration</strong>: TDD fosters collaboration among developers, testers, and business analysts by ensuring alignment on requirements and test scenarios, reducing misunderstandings and improving team communication</li>
<li><strong>Cost Efficiency</strong>: By reducing defects and improving code quality, TDD can lead to lower maintenance costs and a reduced total cost of ownership for the software project</li>
<li><strong>Improved Code Design</strong>: Writing tests first can expose design issues early, as the test code often acts as the first client of the class or component being developed</li>
</ul>
<h3 id="what-does-research-say-about-tdd">What Does Research Say About TDD?</h3>
<p>The research on the effectiveness of TDD has produced mixed results:</p>
<ul>
<li>Janzen (2005) found that TDD practitioners produced less complex algorithms and more comprehensive test suites than non-TDD practitioners</li>
<li>Janzen and Saiedian (2006) observed that TDD led to better use of object-oriented concepts and more effective class responsibility distribution</li>
<li>George and Williams (2003) reported that while TDD initially reduced productivity for inexperienced developers, 92% of developers found it improved code quality</li>
<li>Dogša and Batič (2011) concluded that TDD improved class design due to its simplicity</li>
<li>Erdogmus et al. (2005) found that TDD increased productivity but did not significantly change code quality</li>
<li>Nagappan et al. (2008) observed that TDD reduced pre-release defect density by 40-90% compared to projects that did not use TDD</li>
<li>Müller and Hagner (2002) did not find that TDD accelerated implementation or improved reliability compared to traditional approaches</li>
<li>Siniaalto and Abrahamsson (2007) found that TDD's benefits were unclear in small-scale projects</li>
<li>Shull et al. (2010) reviewed multiple studies on TDD and did not observe a consistent effect on internal code quality</li>
</ul>
<p>Recent studies suggest that the iterative nature of TDD, rather than TDD itself, contributes to improved focus and flow, which can ultimately impact code quality.</p>
<h3 id="when-not-to-use-tdd">When Not to Use TDD</h3>
<p>While TDD is a valuable technique in many software development contexts, there are situations where it may not be the most appropriate approach:</p>
<ul>
<li><strong>Well-understood Problems</strong>: If the problem and its solution are well-understood, writing tests before coding may add little value. Direct coding might be more efficient in such cases, though tests should still be written promptly</li>
<li><strong>Lack of Test Automation</strong>: TDD relies heavily on automated testing to provide quick feedback. If automated testing is not feasible, the TDD approach may not be practical</li>
</ul>
<h3 id="integrating-tdd-and-proper-testing">Integrating TDD and Proper Testing</h3>
<p>It's important to note that TDD is not solely focused on testing; rather, it aids in developing production code by ensuring it meets requirements through automated test cases. Once the TDD cycle is complete, engaging in effective and systematic testing, such as specification-based and structural testing, is essential to ensure comprehensive coverage. The tests created during the TDD process become part of the overall testing suite.</p>
<h3 id="example-walkthrough">Example Walkthrough</h3>
<p>Consider this problem:</p>
<pre><code class="language-java">/**
 * Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.
 *
 * You may assume that each input would have exactly one solution, and you may not use the same element twice.
 *
 * You can return the answer in any order.
 *
 * Example1:
 * Input: nums = [2, 7, 11, 15], target = 9
 * Output: [0, 1]
 * Explanation: Because nums[0] + nums[1] == 0, we return [0, 1]
 *
 * Example2:
 * Input: nums = [3,3], target = 6
 * Output: [0,1]
 *
 * Constraints:
 * &lt;ul&gt;
 *     &lt;li&gt; 2 &lt;= nums.length &lt;= 104 &lt;/li&gt;
 *     &lt;li&gt; -109 &lt;= nums[i] &lt;= 109 &lt;/li&gt;
 *     &lt;li&gt; -109 &lt;= target &lt;= 109 &lt;/li&gt;
 * &lt;/ul&gt;
 */
public int[] twoSum(int[] nums, int target) {
    return null;
}
</code></pre>
<h4 id="red-phase">🔴 Red Phase</h4>
<p>Let's start by devising test cases that check the method constraints.</p>
<pre><code class="language-java">import org.example.Main;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.Arguments;
import org.junit.jupiter.params.provider.MethodSource;

import java.util.stream.IntStream;
import java.util.stream.Stream;

import static org.junit.jupiter.api.Assertions.assertThrows;

public class MainTest {

    private Main main = new Main();

    static Stream&lt;Arguments&gt; invalidInputProvider() {
        // nums length &lt; 2
        int[] nums1 = {1};
        Arguments arguments1 = Arguments.of(nums1, 1);

        // nums length &gt; 104
        int[] nums2 = IntStream.range(0, 105).toArray();
        Arguments arguments2 = Arguments.of(nums2, 1);

        // -109 &lt; num[i]
        int[] nums3 = {1, 6, 4, -110, 2, 3};
        Arguments arguments3 = Arguments.of(nums3, 1);

        // nums[i] &gt; 109
        int[] nums4 = {2, 4, 6, 109, 110};
        Arguments arguments4 = Arguments.of(nums4, 1);

        // target &lt; -109
        int[] nums5 = {-100, -10};
        int target5 = -110;
        Arguments arguments5 = Arguments.of(nums5, target5);

        // target &gt; 110
        int[] nums6 = {55, 11, 67};
        int target6 = 110;
        Arguments arguments6 = Arguments.of(nums6, target6);

        return Stream.of(
            arguments1,
            arguments2,
            arguments3,
            arguments4,
            arguments5,
            arguments6
        );
    }

    @ParameterizedTest
    @MethodSource(&quot;invalidInputProvider&quot;)
    @DisplayName(&quot;Test invalid method inputs&quot;)
    void twoSum_breakMethodConstraints_shouldFail(int[] nums, int target) {
        assertThrows(IllegalArgumentException.class, () -&gt; {
            main.twoSum(nums, target);
        });
    }
}
</code></pre>
<p>This first test forces us to define what should happen if the input is invalid, a case not specified in the method requirements. We decided to throw an <code>IllegalArgumentException</code>.</p>
<h4 id="green-phase">🟢 Green Phase</h4>
<p>Implementing the solution is straightforward. We only need to add the method preconditions.</p>
<pre><code class="language-java">public int[] twoSum(int[] nums, int target) {
    if (nums.length &lt; 2 || nums.length &gt; 104) {
        throw new IllegalArgumentException(&quot;Nums size is not valid!&quot;);
    }
    if (Arrays.stream(nums).anyMatch(num -&gt; num &lt; -109 || num &gt; 109)) {
        throw new IllegalArgumentException(&quot;Nums element is not in bounds!&quot;);
    }
    if (target &lt; -109 || target &gt; 109) {
        throw new IllegalArgumentException(&quot;Target is not valid number!&quot;);
    }

    return null;
}
</code></pre>
<h4 id="refactor-phase">⚫ Refactor Phase</h4>
<p>For refactoring, one could consider extracting the validation checks to a separate method, but we will not do that as the method is not too complex yet.</p>
<p><em>The process continues iteratively:</em></p>
<h4 id="red-phase-next-cycle">🔴 Red Phase (Next Cycle)</h4>
<p>In the next cycle, we'll extend the test suite to verify that the method actually outputs the correct values.</p>
<pre><code class="language-java">static Stream&lt;Arguments&gt; correctValuesAndOutputProvider() {
        // simple length 2 input array
        int[] nums1 = {-109, 109};
        int target1 = 0;
        int[] expected1 = {0, 1};
        Arguments arguments1 = Arguments.of(nums1, target1, expected1);

        // length 3 input array
        int[] nums2 = {5, 17, 92};
        int target2 = 109;
        int[] expected2 = {1, 2};
        Arguments arguments2 = Arguments.of(nums2, target2, expected2);

        // length 4 input array
        int[] nums3 = {1, 6, 6, 10};
        int target3 = 12;
        int[] expected3 = {1, 2};
        Arguments arguments3 = Arguments.of(nums3, target3, expected3);

        // length 104 input array
        int[] nums4 = new int[104];
        for (int i = 0; i &lt; 102; i++) {
 nums4[i] = 0;
 }
 nums4[102] = 9;
 nums4[103] = 10;
        int target4 = 19;
        int[] expected4 = {102, 103};
        Arguments arguments4 = Arguments.of(nums4, target4, expected4);

        return Stream.of(
 arguments1,
 arguments2,
 arguments3,
 arguments4
 );
 }

 @ParameterizedTest
 @MethodSource(&quot;correctValuesAndOutputProvider&quot;)
 @DisplayName(&quot;Test correct method output&quot;)
    void twoSum_correctInput_correctOutput(int[] nums, int target, int[] expected) {
        int[] result = main.twoSum(nums, target);
        Arrays.sort(expected);
        Arrays.sort(result);

        assertArrayEquals(expected, result);
 }
</code></pre>
<h4 id="green-phase_1">🟢 Green Phase</h4>
<p>Implementing the solution that passes the tests.</p>
<pre><code class="language-java">public int[] twoSum(int[] nums, int target) {
    if (nums.length &lt; 2 || nums.length &gt; 104) {
        throw new IllegalArgumentException(&quot;Nums size is not valid!&quot;);
    }
    if (Arrays.stream(nums).anyMatch(num -&gt; num &lt; -109 || num &gt; 109)) {
        throw new IllegalArgumentException(&quot;Nums element is not in bounds!&quot;);
    }
    if (target &lt; -109 || target &gt; 109) {
        throw new IllegalArgumentException(&quot;Target is not valid number!&quot;);
    }

    int[] result = new int[2];

    outterLoop:
    for (int i = 0; i &lt; nums.length - 1; i++) {
        for (int j = i+1; j &lt; nums.length; j++) {
            if (nums[i] + nums[j] == target) {
                result[0] = i;
                result[1] = j;
                break outterLoop;
            }
        }
    }

    return result;
}
</code></pre>
<h4 id="refactor-phase_1">⚫ Refactor Phase</h4>
<p>😛😛</p>
<h4 id="red-phase-final-cycle">🔴 Red Phase (Final Cycle)</h4>
<p>Next, let's test the case where the method can't find a result.</p>
<pre><code class="language-java">@Test
void twoSum_correctInput_cantFindResult() {
    int[] nums = {1, 3, 5, 7};
    int target = 5;

    assertNull(main.twoSum(nums, target));
}
</code></pre>
<h4 id="green-phase_2">🟢 Green Phase</h4>
<p>Updating the implementation to handle this case.</p>
<pre><code class="language-java">public int[] twoSum(int[] nums, int target) {
    if (nums.length &lt; 2 || nums.length &gt; 104) {
        throw new IllegalArgumentException(&quot;Nums size is not valid!&quot;);
    }
    if (Arrays.stream(nums).anyMatch(num -&gt; num &lt; -109 || num &gt; 109)) {
        throw new IllegalArgumentException(&quot;Nums element is not in bounds!&quot;);
    }
    if (target &lt; -109 || target &gt; 109) {
        throw new IllegalArgumentException(&quot;Target is not valid number!&quot;);
    }
    int[] result = null;

    outterLoop:
    for (int i = 0; i &lt; nums.length - 1; i++) {
        for (int j = i+1; j &lt; nums.length; j++) {
            if (nums[i] + nums[j] == target) {
                result = new int[]{i, j};
                break outterLoop;
            }
        }
    }

    return result;
}
</code></pre>
<h4 id="final-refactor">⚫ Final Refactor</h4>
<p>Now, the method meets the expected functionality. We could consider rewriting the nested loop, adding post-conditions, or improving the method runtime (<code>O(n)</code> is possible) for further refactoring. These are left as exercises for the reader.</p>
<pre><code class="language-java">TODO
</code></pre>
<h2 id="writing-larger-tests">Writing Larger Tests</h2>
<p><em>[TODO]</em></p>
<h2 id="test-code-quality">Test Code Quality</h2>
<p><em>[TODO]</em></p>
<hr />
<p><em>This guide provides a comprehensive overview of effective software testing practices. For more advanced topics and specific implementation details, consider referring to additional resources and the original book by Maurício Aniche.</em></p>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="../open-webui-action-tools/" class="btn btn-neutral float-left" title="Beyond Text. Equipping Your Open WebUI AI with Action Tools"><span class="icon icon-circle-arrow-left"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
      <span><a href="../open-webui-action-tools/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
  </span>
</div>
    <script src="../../js/jquery-3.6.0.min.js"></script>
    <script>var base_url = "../..";</script>
    <script src="../../js/theme_extra.js"></script>
    <script src="../../js/theme.js"></script>
      <script src="../../search/main.js"></script>
    <script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>

</body>
</html>
